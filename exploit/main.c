/*--------------------------
  $ gcc --version
  gcc (GCC) 8.2.1 20181127
--------------------------*/
/* セキュアなコーディングを心がける. */

#include <stdio.h>
#include <string.h>

int main()
{
  char buf[4]; // char + char + char + \0
  char data[] = "Buffer Over Flow!";
  // exploit
  /* char *gets(char *dest); */
  // alternative
  /* char *fgets(char *dest, int n, FILE *stream); */
  //gets(gets_buf); // BOF
  printf("fgets(): ");
  fgets(buf, sizeof buf, stdin);
  printf("fgets: %s\n", buf); // この場合, 入力文字の先頭3文字が表示される


  // exploit
  /* char *strcpy(char *dest, const char *src); */
  // alternative
  /* char *strncpy(char *dest, const char *src, size_t n); */
  memset(buf, 0, sizeof buf);
  //strcpy(strcpy_buf, data);  // BOFしない... 全文表示された
  strncpy(buf, data, sizeof(buf)-1); // 最後はnull文字
  printf("strncpy: %s\n", buf);


  // exploit
  /* char *strcat(char *dest, const char *src); */
  // alternative
  /* char *strncat(char *dest, const char *src, size_t n); */
  memset(buf, 0, sizeof buf);
  //strcat(buf, data);  // BOFしない... 全文表示された
  strncpy(buf, data, sizeof(buf)-strlen(buf)-1); // 最後はnull文字
  printf("strncat: %s\n", buf);


  // exploit
  /* int sprintf(char *dest, const char *format, ...); */
  // alternative
  /* int snprintf(char *dest, size_t n, const char *format, ...); */
  //sprintf(buf, "%s", data); //BOFしない... 全文表示された
  snprintf(buf, sizeof buf, "%s", data);
  //sprintf(buf, "%.3s", data); // "%.文字数s"で精度を指定しても良い
  printf("sprintf: %s\n", buf);


  // exploit
  /* int scanf(const char *format, ...); */ // 空白,タブ,改行まで読み込む
  //memset(buf, 0, sizeof buf);
  //fflush(stdin);
  //fflush(stdout);
  printf("scanf(): ");
  scanf("%.3s", buf); // 精度を指定する
  printf("scanf: %s\n", buf);


  // 戻り値がvoidの関数はエラーチェックができにくい.
  // 同じ処理なら戻り値のある関数を優先して使う.
  // 例. setbuf() -> setvbuf()
  /* void setbuf(FILE *restrict stream, char *restrict buf); */
  /* int setvbuf(FILE *restrict stream, char *restrict buf,
                 int mode, size_t size); */


  // exploit
  /* int ssscanf(const char *restrict s, const char *restrict format, ...); */
  /* int fscanf(FILE *fp, const char *format, ...); */
  char s[] = "12345 abc hogehoge";
  sscanf(s, "%.3s", buf);  // 精度を指定する
  //FILE *fp;
  //fscanf(fp, "%.3s", buf); // 精度を指定する
  printf("%s\n", buf);


  // exploit
  /* int vfscanf(FILE *fp, const char *format, va_list arg); */
  /* int vscanf(const char *format, va_list arg); */
  /* int vsscanf(const char *str, const char *format, va_list arg); */
  // 上記は精度を指定するか, データサイズのチェックを行う.


  // exploit
  /* int vsprintf(char *str, const char *format, va_list arg); */
  // alternative
  /* int vsnprintf(char *str, size_t n, const char *format, va_list arg); */
  // 精度を指定するか, データサイズのチェックを行う.


  /* int system(const char *str); */
  //char command[] = "危険な文字列";
  //system(command);
  //system("./a.out"); // sh: 1: cannot fork
  //snprintf(command, SIZE, "ls -l %s", argv[1]);
  // このような場合も不正な文字列を入力されるとやばい
  // 対策
  // ",", "\", "|", "&", "(", ")", "`" 等の特殊記号が含まれていないかチェック
  //                                ^ バッククォート
  // regexを用いて, 英数字"^[A-Za-z0-9]+$"のみを許可してチェック
  // そもそもなるべく使わない
  // alternative
  /* exec系の関数を使う */
}
